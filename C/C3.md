# TOPSIS多属性决策分析方法

## 模型简介

TOPSIS(Technique for Order Preference by Similarity to Ideal Solution)是一种基于理想解相似性的多属性决策分析方法，通过计算各方案到正理想解和负理想解的距离，确定最优方案排序。

## 适用场景

### 数学建模竞赛中的典型应用

1. **供应商选择** - 基于价格、质量、服务等多指标选择供应商
2. **投资决策** - 根据收益率、风险、流动性等评估投资方案
3. **产品评价** - 综合性能、价格、用户满意度等选择产品
4. **城市排名** - 基于经济、环境、教育等指标排名城市
5. **员工评价** - 综合工作能力、态度、业绩等评价员工
6. **学校选择** - 考虑排名、费用、地理位置等选择学校
7. **技术方案** - 比较成本、效率、可靠性等选择技术方案
8. **政策评估** - 评估政策在经济、社会、环境等方面的影响

### 典型问题特征

- 存在多个待选方案
- 每个方案有多个评价指标
- 指标间可能存在冲突关系
- 需要综合考虑所有指标进行排序

## 算法原理

### 基本步骤

1. **构建决策矩阵**: 方案×指标的数据矩阵
2. **矩阵标准化**: 消除量纲影响
3. **确定权重**: 各指标的重要程度
4. **计算加权标准化矩阵**: 标准化矩阵乘以权重
5. **确定理想解**: 正理想解和负理想解
6. **计算距离**: 各方案到理想解的欧几里得距离
7. **计算相对贴近度**: 综合考虑到两个理想解的距离
8. **排序**: 按相对贴近度排序

### 数学公式

**标准化**:
$$r_{ij} = \frac{x_{ij}}{\sqrt{\sum_{i=1}^m x_{ij}^2}}$$

**加权标准化**:
$$v_{ij} = w_j \times r_{ij}$$

**理想解**:
- 正理想解: $A^+ = \{v_1^+, v_2^+, ..., v_n^+\}$
- 负理想解: $A^- = \{v_1^-, v_2^-, ..., v_n^-\}$

**相对贴近度**:
$$C_i = \frac{S_i^-}{S_i^+ + S_i^-}$$

## 使用方法

### 1. 基本调用

```python
from M_C3_TOPSIS import topsis
import numpy as np

# 构建决策矩阵 (方案×指标)
decision_matrix = np.array([
    [250, 90, 10, 8],   # 方案A
    [280, 80, 12, 7],   # 方案B  
    [220, 95, 8,  9],   # 方案C
    [300, 85, 15, 6]    # 方案D
])

# 设置权重和指标类型
weights = np.array([0.3, 0.3, 0.2, 0.2])
impacts = ['-', '+', '-', '+']  # '-'成本型, '+'效益型

# 运行TOPSIS
scores, ranking = topsis(decision_matrix, weights, impacts)

# 查看结果
for i, score in enumerate(scores):
    print(f"方案{i+1}: 得分={score:.4f}, 排名={ranking[i]}")
```

### 2. 参数说明

- **matrix**: 决策矩阵 (m×n)，m个方案，n个指标
- **weights**: 权重向量 (n×1)，各指标权重，和为1
- **impacts**: 指标类型列表
  - '+': 效益型指标 (越大越好)
  - '-': 成本型指标 (越小越好)

### 3. 权重确定方法

```python
# 方法1: 专家打分法
weights = np.array([0.3, 0.3, 0.2, 0.2])

# 方法2: 熵权法
def entropy_weight(matrix):
    # 标准化
    prob = matrix / matrix.sum(axis=0)
    # 计算熵值
    entropy = -np.sum(prob * np.log(prob + 1e-10), axis=0) / np.log(len(matrix))
    # 计算权重
    weights = (1 - entropy) / (1 - entropy).sum()
    return weights

# 方法3: 主成分分析法
from sklearn.decomposition import PCA
pca = PCA()
pca.fit(matrix)
weights = pca.explained_variance_ratio_[:len(impacts)]
weights = weights / weights.sum()

# 方法4: 层次分析法(AHP)
def ahp_weight(comparison_matrix):
    # 计算特征向量作为权重
    eigenvalues, eigenvectors = np.linalg.eig(comparison_matrix)
    max_index = np.argmax(eigenvalues)
    weights = np.real(eigenvectors[:, max_index])
    return weights / weights.sum()
```

### 4. 敏感性分析

```python
# 权重敏感性分析
def sensitivity_analysis(matrix, impacts, weight_range=0.1):
    base_weights = np.array([0.3, 0.3, 0.2, 0.2])
    results = {}
    
    for i in range(len(base_weights)):
        for delta in [-weight_range, weight_range]:
            new_weights = base_weights.copy()
            new_weights[i] += delta
            new_weights = new_weights / new_weights.sum()  # 归一化
            
            scores, ranking = topsis(matrix, new_weights, impacts)
            results[f'指标{i+1}{delta:+.1f}'] = ranking
    
    return results
```

## 算法优缺点

### 优点

1. **简单易懂**: 原理清晰，易于理解和实现
2. **适用性广**: 可处理各种类型的多属性决策问题
3. **客观性强**: 基于数学计算，避免主观偏见
4. **结果直观**: 得分和排名结果易于解释

### 缺点

1. **权重依赖**: 结果对权重设置较为敏感
2. **线性假设**: 假设指标间关系为线性
3. **等重要性**: 正负理想解的重要性相等
4. **数据要求**: 需要完整的定量数据

## 注意事项

### 数据预处理

1. **数据类型**: 所有指标应为定量数据
2. **数据完整**: 不能有缺失值
3. **异常值**: 异常值会显著影响结果
4. **量纲统一**: 通过标准化消除量纲影响

### 权重设置

1. **权重和为1**: 确保权重向量归一化
2. **合理性检验**: 权重应反映指标的实际重要性
3. **敏感性分析**: 分析权重变化对结果的影响
4. **多种方法**: 结合多种权重确定方法

### 结果解释

1. **相对性**: TOPSIS给出的是相对排序，不是绝对优劣
2. **完整性**: 增减方案会改变其他方案的排序
3. **聚类分析**: 可结合聚类将方案分组
4. **阈值设置**: 可设置决策阈值筛选方案

## 代码文件

- **文件名**: `M_C3_TOPSIS.py`  
- **主函数**: `topsis(matrix, weights, impacts)`
- **示例**: 4个供应商基于4个指标的评价分析

## 扩展应用

### 改进方法

1. **模糊TOPSIS**: 处理模糊不确定信息
2. **灰色TOPSIS**: 处理信息不完全问题
3. **动态TOPSIS**: 考虑时间因素的动态决策
4. **群体TOPSIS**: 集成多个决策者的偏好

### 相关方法

1. **ELECTRE**: 基于优序关系的多属性决策
2. **PROMETHEE**: 基于偏好的多准则决策
3. **AHP**: 层次分析法，适用于层次结构问题
4. **VIKOR**: 基于妥协排序的决策方法

### 实际应用技巧

1. **指标选择**: 选择独立性强、代表性好的指标
2. **数据收集**: 确保数据的准确性和可比性
3. **结果验证**: 通过其他方法验证结果的合理性
4. **决策支持**: 结合专家经验和实际约束