# 层次分析法 (AHP - Analytic Hierarchy Process)

## 模型简介

层次分析法是一种定性与定量相结合的多准则决策分析方法，通过构建判断矩阵和计算权重向量，将复杂的决策问题分解为有序的递阶层次结构，为多属性决策提供科学的权重确定方法。

## 适用场景

### 数学建模竞赛中的典型应用

1. **供应商评价** - 基于价格、质量、服务等准则确定权重
2. **投资决策分析** - 风险、收益、流动性等因素权重分配
3. **城市发展评估** - 经济、环境、社会等指标权重确定
4. **产品质量评价** - 性能、外观、价格等属性权重计算
5. **人员选拔评估** - 能力、经验、潜力等指标权重设定
6. **项目优先级排序** - 成本、效益、风险等因素综合评价
7. **政策方案比较** - 经济效果、社会影响、实施难度权重
8. **技术方案选择** - 技术先进性、成本、可行性权重确定

### 典型问题特征

- 需要多个评价准则的权重确定
- 准则之间可以进行两两比较
- 专家判断或经验数据可获得
- 要求权重计算的科学性和一致性

## 算法原理

### 基本步骤

1. **建立层次结构**: 目标层-准则层-方案层
2. **构造判断矩阵**: 准则间两两比较的重要程度
3. **计算权重向量**: 特征值法求解权重
4. **一致性检验**: 检查判断矩阵的逻辑一致性
5. **层次总排序**: 自上而下逐层计算综合权重

### 判断标度

| 标度 | 含义 | 说明 |
|------|------|------|
| 1 | 同等重要 | 两个因素相比，具有同等重要性 |
| 3 | 稍微重要 | 两个因素相比，一个因素比另一个因素稍微重要 |
| 5 | 明显重要 | 两个因素相比，一个因素比另一个因素明显重要 |
| 7 | 强烈重要 | 两个因素相比，一个因素比另一个因素强烈重要 |
| 9 | 极端重要 | 两个因素相比，一个因素比另一个因素极端重要 |
| 2,4,6,8 | 中间值 | 上述相邻判断的中间值 |
| 倒数 | 反比较 | 因素i与j比较得到判断aij，则因素j与i比较得到aji=1/aij |

### 数学公式

**判断矩阵**：
$$A = (a_{ij})_{n \times n}, \quad a_{ij} = \frac{1}{a_{ji}}, \quad a_{ii} = 1$$

**特征值方法**：
$$A \cdot w = \lambda_{max} \cdot w$$

**一致性指标**：
$$CI = \frac{\lambda_{max} - n}{n - 1}$$

**一致性比率**：
$$CR = \frac{CI}{RI}$$

## 使用方法

### 1. 基本调用

```python
from M_C4_AHP import AHP, ahp_analysis
import numpy as np

# 构建判断矩阵 (4个评价准则)
matrix = np.array([
    [1,   1/3, 1/2, 1/4],  # 准则1相对于其他准则的重要程度
    [3,   1,   2,   1/2],  # 准则2相对于其他准则的重要程度
    [2,   1/2, 1,   1/3],  # 准则3相对于其他准则的重要程度
    [4,   2,   3,   1  ]   # 准则4相对于其他准则的重要程度
])

# 准则名称
criteria = ['价格', '质量', '服务', '交期']

# 进行AHP分析
result = ahp_analysis(matrix, criteria, display=True)

# 查看结果
if result['consistency']['is_consistent']:
    print("权重计算结果：")
    for name, weight in zip(criteria, result['weights']):
        print(f"{name}: {weight:.4f}")
```

### 2. 面向对象使用

```python
# 创建AHP对象
ahp = AHP()

# 输入判断矩阵
ahp.input_matrix(matrix)

# 计算权重（三种方法可选）
weights = ahp.calculate_weights(method='eigenvalue')  # 特征值法（推荐）
# weights = ahp.calculate_weights(method='geometric')   # 几何平均法
# weights = ahp.calculate_weights(method='arithmetic')  # 算术平均法

# 一致性检验
consistency = ahp.consistency_check()
print(f"一致性比率CR = {consistency['CR']:.4f}")

# 显示完整结果
ahp.display_results()

# 绘制权重分布图
ahp.plot_weights()
```

### 3. 交互式创建矩阵

```python
# 交互式输入判断矩阵
from M_C4_AHP import create_comparison_matrix_interactive

matrix, factors = create_comparison_matrix_interactive()
result = ahp_analysis(matrix, factors)
```

### 4. 参数说明

**ahp_analysis()函数参数**：
- **matrix**: array-like, 判断矩阵 (n×n)
- **factors**: list, 因子名称列表 (可选)
- **method**: str, 权重计算方法 ('eigenvalue', 'geometric', 'arithmetic')
- **display**: bool, 是否显示详细结果

**返回值**：
- **weights**: ndarray, 权重向量
- **consistency**: dict, 一致性检验结果
  - **CR**: float, 一致性比率
  - **is_consistent**: bool, 是否通过一致性检验

## 一致性检验

### 检验标准

- **CR < 0.01**: 完全一致
- **CR < 0.05**: 高度一致  
- **CR < 0.10**: 可接受一致
- **CR ≥ 0.10**: 不一致，需要重新调整矩阵

### 改善一致性的方法

1. **重新评估判断**: 检查是否存在明显不合理的比较
2. **专家讨论**: 通过专家组讨论达成共识
3. **分层细化**: 将复杂准则分解为更细的子准则
4. **数据验证**: 用实际数据验证专家判断的合理性

## 注意事项

### 矩阵构建

1. **倒数关系**: 确保 aij = 1/aji
2. **对角线为1**: aii = 1
3. **正数矩阵**: 所有元素必须大于0
4. **传递性**: 尽量满足 aik ≈ aij × ajk

### 判断质量

1. **专业性**: 判断者应对比较对象有深入了解
2. **独立性**: 避免受他人意见影响
3. **一致性**: 逻辑前后一致，避免循环判断
4. **经验性**: 结合实际经验和客观数据

### 使用限制

1. **主观性**: 结果依赖于专家的主观判断
2. **规模限制**: 一般建议单层准则不超过9个
3. **动态性**: 权重可能随时间和环境变化
4. **文化差异**: 不同文化背景可能影响判断标准

## 代码文件

- **文件名**: `M_C4_AHP.py`
- **主要类**: `AHP`
- **主函数**: `ahp_analysis(matrix, factors, method, display)`
- **交互函数**: `create_comparison_matrix_interactive()`
- **示例**: 供应商选择的4准则权重计算

## 扩展应用

### 复杂层次结构

```python
# 三层AHP结构示例
# 目标层：选择最佳供应商
# 准则层：价格、质量、服务
# 方案层：供应商A、B、C

# 步骤1：准则层权重
criteria_matrix = np.array([[1, 1/2, 2], [2, 1, 3], [1/2, 1/3, 1]])
criteria_weights = ahp_analysis(criteria_matrix)['weights']

# 步骤2：各准则下的方案权重
price_matrix = np.array([[1, 3, 2], [1/3, 1, 1/2], [1/2, 2, 1]])
quality_matrix = np.array([[1, 1/2, 1/3], [2, 1, 1/2], [3, 2, 1]])
service_matrix = np.array([[1, 2, 4], [1/2, 1, 2], [1/4, 1/2, 1]])

price_weights = ahp_analysis(price_matrix)['weights']
quality_weights = ahp_analysis(quality_matrix)['weights'] 
service_weights = ahp_analysis(service_matrix)['weights']

# 步骤3：综合权重计算
final_weights = np.array([price_weights, quality_weights, service_weights]).T @ criteria_weights
```

### 群体AHP

```python
def group_ahp(matrices_list, method='geometric_mean'):
    """群体AHP权重聚合"""
    n = len(matrices_list)
    
    if method == 'geometric_mean':
        # 几何平均法聚合判断矩阵
        product_matrix = np.ones_like(matrices_list[0])
        for matrix in matrices_list:
            product_matrix *= matrix
        group_matrix = np.power(product_matrix, 1/n)
    
    elif method == 'weighted_average':
        # 加权平均法（需要专家权重）
        expert_weights = [1/n] * n  # 等权重
        group_matrix = np.zeros_like(matrices_list[0])
        for i, matrix in enumerate(matrices_list):
            group_matrix += expert_weights[i] * matrix
    
    return ahp_analysis(group_matrix)
```

### 敏感性分析

```python
def sensitivity_analysis(matrix, perturbation=0.1):
    """AHP权重敏感性分析"""
    base_result = ahp_analysis(matrix, display=False)
    base_weights = base_result['weights']
    
    results = {}
    n = matrix.shape[0]
    
    for i in range(n):
        for j in range(i+1, n):
            # 扰动矩阵元素
            perturbed_matrix = matrix.copy()
            perturbed_matrix[i,j] *= (1 + perturbation)
            perturbed_matrix[j,i] = 1.0 / perturbed_matrix[i,j]
            
            # 计算扰动后的权重
            perturbed_result = ahp_analysis(perturbed_matrix, display=False)
            if perturbed_result['consistency']['is_consistent']:
                weight_change = perturbed_result['weights'] - base_weights
                results[f'element({i+1},{j+1})'] = {
                    'weight_change': weight_change,
                    'max_change': np.max(np.abs(weight_change))
                }
    
    return results
```

### 应用技巧

1. **预处理**: 通过预调研确定合理的判断矩阵范围
2. **验证**: 用其他方法（如熵权法）验证权重合理性
3. **更新**: 定期更新判断矩阵以反映最新情况
4. **文档化**: 详细记录判断依据和决策过程