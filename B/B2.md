# Dijkstra算法 (单源最短路径)

## 模型简介

Dijkstra算法是一种用于在加权图中找到单源最短路径的经典算法，由荷兰计算机科学家艾兹格·迪克斯特拉在1956年提出。该算法能够找到从起点到图中所有其他点的最短路径。

## 适用场景

### 数学建模竞赛中的典型应用

1. **物流配送** - 寻找配送中心到各个网点的最短路径
2. **交通规划** - 城市道路网络中的最优路径规划
3. **网络路由** - 数据包在计算机网络中的最优传输路径
4. **应急救援** - 救援队伍到达各个地点的最快路径
5. **设施选址** - 选择服务设施的最优位置
6. **供应链优化** - 供应商到客户的最低成本路径
7. **旅游路线** - 景点之间的最短游览路径
8. **管道铺设** - 最小成本的管道网络设计

### 典型问题特征

- 图中所有边权重非负
- 需要从单个源点到所有其他点的最短距离
- 图可以是稠密的也可以是稀疏的
- 需要同时得到最短距离和最短路径

## 算法原理

### 基本思想

1. **贪心策略**: 每次选择距离起点最近且未处理的节点
2. **松弛操作**: 通过已确定的最短路径更新其邻接节点的距离
3. **优先级队列**: 使用堆结构高效选择下一个处理节点

### 算法步骤

1. 初始化距离数组，起点距离为0，其他点为无穷大
2. 将起点加入优先队列
3. 从队列中取出距离最小的节点作为当前节点
4. 对当前节点的所有邻居进行松弛操作
5. 将更新后的邻居节点加入队列
6. 重复步骤3-5直到队列为空

## 使用方法

### 1. 基本调用

```python
from M_B2_Dijkstra import dijkstra

# 定义图结构 (邻接表表示)
graph = {
    'A': {'B': 4, 'C': 2},
    'B': {'C': 1, 'D': 5},
    'C': {'D': 8, 'E': 10},
    'D': {'E': 2},
    'E': {}
}

# 运行算法
distances, paths = dijkstra(graph, 'A')

# 查看结果
for node, dist in distances.items():
    print(f"A到{node}的最短距离: {dist}")
    print(f"路径: {' -> '.join(paths[node])}")
```

### 2. 参数说明

- **graph**: dict, 图的邻接表表示
  - 格式: `{'节点': {'邻居1': 权重1, '邻居2': 权重2, ...}}`
- **start_node**: 起始节点（必须是graph中的键）

### 3. 返回值说明

- **distances**: dict, 从起点到各节点的最短距离
- **paths**: dict, 从起点到各节点的完整路径

### 4. 图的构建方式

```python
# 方式1：手动构建
graph = {
    'A': {'B': 1, 'C': 4},
    'B': {'A': 1, 'C': 2, 'D': 5},
    'C': {'A': 4, 'B': 2, 'D': 1},
    'D': {'B': 5, 'C': 1}
}

# 方式2：从邻接矩阵转换
import numpy as np
adj_matrix = np.array([
    [0, 1, 4, 0],
    [1, 0, 2, 5],
    [4, 2, 0, 1],
    [0, 5, 1, 0]
])
nodes = ['A', 'B', 'C', 'D']
graph = {}
for i, node in enumerate(nodes):
    graph[node] = {}
    for j, neighbor in enumerate(nodes):
        if adj_matrix[i][j] > 0:
            graph[node][neighbor] = adj_matrix[i][j]
```

## 算法复杂度

- **时间复杂度**: O((V + E) log V)，其中V是节点数，E是边数
- **空间复杂度**: O(V)
- **适用图规模**: 中等规模图（V < 10^5）

## 注意事项

1. **非负权重**: 算法要求所有边权重非负，负权重会导致错误结果
2. **图连通性**: 不连通的节点距离将保持为无穷大
3. **自环处理**: 算法可以处理自环，但通常不影响最短路径
4. **重复边**: 如果存在重复边，保留权重最小的边

## 代码文件

- **文件名**: `M_B2_Dijkstra.py`
- **主函数**: `dijkstra(graph, start_node)`
- **示例**: 简单4节点图的最短路径计算

## 扩展应用

### 相关算法

1. **Floyd-Warshall**: 全源最短路径，适用于稠密图
2. **Bellman-Ford**: 可处理负权重边的单源最短路径
3. **A*搜索**: 启发式搜索，适用于特定目标的路径规划

### 实际应用技巧

1. **路径重构**: 除了距离还需要具体路径时的处理
2. **动态图**: 图结构变化时的增量更新
3. **多源问题**: 多次调用处理多个起点
4. **约束路径**: 带有经过特定节点约束的路径规划