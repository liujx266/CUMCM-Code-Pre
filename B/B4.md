# 模拟退火算法 (Simulated Annealing)

## 模型简介

模拟退火算法是一种基于物理退火过程的全局优化算法，通过模拟金属冷却过程中原子的运动，在搜索过程中以一定概率接受更差的解，从而跳出局部最优，寻找全局最优解。

## 适用场景

### 数学建模竞赛中的典型应用

1. **组合优化** - 旅行商问题(TSP)、背包问题、调度问题
2. **路径规划** - 最短路径、车辆路径优化
3. **资源分配** - 任务分配、设施选址问题
4. **参数优化** - 复杂函数的全局最优解
5. **图论问题** - 图着色、最大团问题
6. **工程设计** - 结构优化、系统参数调优
7. **金融建模** - 投资组合优化、风险管理
8. **机器学习** - 神经网络训练、特征选择

### 典型问题特征

- 目标函数复杂、多峰、非连续
- 搜索空间大，存在多个局部最优
- 传统优化方法易陷入局部最优
- 对初值不敏感的全局搜索需求

## 算法原理

### 物理背景

模拟金属退火过程：
1. **高温阶段**: 原子运动剧烈，系统能量高
2. **缓慢冷却**: 逐步降低温度
3. **低温稳定**: 原子趋向稳定，达到全局最优状态

### 算法流程

1. **初始化**: 设定初始温度T₀、初始解x₀
2. **邻域搜索**: 在当前解附近生成新解
3. **接受准则**: 
   - 若新解更优：直接接受
   - 若新解更差：以概率 $e^{-\Delta f/T}$ 接受
4. **降温**: 按cooling_rate降低温度
5. **终止**: 温度足够低或达到迭代次数

### 关键参数

- **初始温度T₀**: 影响初期接受差解的概率
- **降温率α**: 控制降温速度 (0.8-0.99)
- **最低温度**: 算法终止条件
- **邻域生成**: 决定搜索的有效性

## 使用方法

### 1. 连续函数优化

```python
from M_B4_SimulatedAnnealing import simulated_annealing
import numpy as np

# 定义目标函数
def rastrigin(x):
    A = 10
    n = len(x)
    return A * n + sum(xi**2 - A * np.cos(2 * np.pi * xi) for xi in x)

# 设置参数
bounds = [[-5.12, 5.12], [-5.12, 5.12]]  # 变量范围

# 运行算法
best_sol, best_val, history = simulated_annealing(
    rastrigin, bounds, 
    initial_temp=100,
    cooling_rate=0.95,
    max_iter=5000
)

print(f"最优解: {best_sol}")
print(f"最优值: {best_val}")
```

### 2. 旅行商问题(TSP)

```python
from M_B4_SimulatedAnnealing import sa_tsp
import numpy as np

# 距离矩阵
distance_matrix = np.array([
    [0,  29, 20, 21],
    [29, 0,  15, 29], 
    [20, 15, 0,  15],
    [21, 29, 15, 0 ]
])

# 求解TSP
best_path, best_distance = sa_tsp(distance_matrix)

print(f"最优路径: {best_path}")
print(f"最短距离: {best_distance}")
```

### 3. 参数调优指南

```python
# 高质量解的参数设置
best_sol, best_val, history = simulated_annealing(
    objective_func, bounds,
    initial_temp=1000,    # 初始温度要足够高
    cooling_rate=0.99,    # 缓慢降温
    min_temp=1e-6,        # 充分降温
    max_iter=10000        # 充足迭代
)

# 快速求解的参数设置  
best_sol, best_val, history = simulated_annealing(
    objective_func, bounds,
    initial_temp=100,     # 较低初始温度
    cooling_rate=0.9,     # 快速降温
    max_iter=1000         # 较少迭代
)
```

## 算法特点

### 优点
1. **全局搜索** - 能跳出局部最优，寻找全局最优
2. **适应性强** - 适用于连续和离散优化问题
3. **鲁棒性好** - 对初值和参数不太敏感
4. **通用性强** - 只需定义目标函数和邻域操作

### 缺点
1. **收敛慢** - 需要较多的函数计算
2. **参数敏感** - 温度参数设置影响性能
3. **随机性** - 结果有随机性，需要多次运行
4. **局部搜索弱** - 后期局部搜索能力有限

## 改进策略

### 1. 参数自适应

```python
# 自适应降温策略
def adaptive_cooling(initial_temp, iteration, total_iter):
    return initial_temp * (1 - iteration / total_iter)**2

# 自适应扰动
def adaptive_perturbation(bounds, temperature, initial_temp):
    scale = temperature / initial_temp
    return np.random.normal(0, scale * (bounds[:, 1] - bounds[:, 0]) / 10)
```

### 2. 混合算法

```python
# SA + 局部搜索
def hybrid_sa(objective_func, bounds):
    # 先用SA找到好的起点
    sa_solution, _, _ = simulated_annealing(objective_func, bounds)
    
    # 再用局部搜索精化
    from scipy.optimize import minimize
    result = minimize(objective_func, sa_solution, 
                     bounds=bounds, method='L-BFGS-B')
    
    return result.x, result.fun
```

### 3. 多重启策略

```python
def multi_restart_sa(objective_func, bounds, n_restarts=5):
    best_sol = None
    best_val = float('inf')
    
    for _ in range(n_restarts):
        sol, val, _ = simulated_annealing(objective_func, bounds)
        if val < best_val:
            best_val = val
            best_sol = sol
    
    return best_sol, best_val
```

## 注意事项

### 参数设置
1. **初始温度**: 使初期约80%的差解被接受
2. **降温率**: 0.9-0.99，复杂问题用较大值
3. **终止条件**: 温度足够低或连续多代无改进

### 问题适应
1. **邻域设计**: 要能够到达所有可行解
2. **边界处理**: 确保新解在可行域内
3. **目标函数**: 避免数值计算异常

## 代码文件

- **文件名**: `M_B4_SimulatedAnnealing.py`
- **主函数**: 
  - `simulated_annealing()`: 通用SA算法
  - `sa_tsp()`: TSP专用SA算法
- **示例**: Rastrigin函数优化、5城市TSP问题

## 扩展应用

### 问题变种
1. **多目标SA**: 处理多目标优化问题
2. **并行SA**: 多个温度链并行搜索  
3. **量子SA**: 结合量子计算概念
4. **自适应SA**: 参数自动调整

### 实际应用
1. **VLSI设计**: 芯片布局优化
2. **生产调度**: 车间作业调度
3. **网络设计**: 通信网络拓扑优化
4. **图像处理**: 图像分割、特征匹配